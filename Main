from tkinter import simpledialog, messagebox, Scrollbar
from tkinter import ttk
import tkinter as tk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class MemoryManager:
    def __init__(self):
        self.total_memory_size = None
        self.page_size = None
        self.swap_size = None
        self.memory = []  # Added memory attribute
        self.swap_memory = []
        self.last_allocated = 0

    def initialize_memory(self, gui_instance):
        self.total_memory_size = simpledialog.askinteger("Configuração", "Digite o tamanho total da memória (em bytes):")
        self.page_size = simpledialog.askinteger("Configuração", "Digite o tamanho de uma página (em bytes):")
        self.swap_size = simpledialog.askinteger("Configuração", "Digite o tamanho total do swap (em bytes):")
        if self.total_memory_size and self.page_size and self.swap_size:
            self.memory = [{"ocupada": False, "lotada": False} for _ in range(self.total_memory_size // self.page_size)]
            self.swap_memory = [{"ocupada": False, "lotada": False} for _ in range(self.swap_size // self.page_size)]
            messagebox.showinfo("Configuração", "Memória inicializada com sucesso.")
            gui_instance.show_memory_graph()

    def allocate_memory(self, num_pages):
        allocated = 0
        for page in self.memory:
            if allocated == num_pages:
                break
            if not page["ocupada"]:
                page["ocupada"] = True
                allocated += 1

        if allocated < num_pages:
            for page in self.swap_memory:
                if allocated == num_pages:
                    break
                if not page["ocupada"]:
                    page["ocupada"] = True
                    allocated += 1

        if allocated < num_pages:
            return f"Alocação parcial: {allocated} páginas alocadas, não há espaço suficiente para todas as páginas."

        if allocated == len(self.memory) + len(self.swap_memory):
            for page in self.memory:
                page["lotada"] = True
            for page in self.swap_memory:
                page["lotada"] = True

        return f"{allocated} páginas alocadas."

    def deallocate_memory(self, page_number):
        if page_number < len(self.memory):
            page = self.memory[page_number]
            if page["ocupada"]:
                page["ocupada"] = False
                return f"Página {page_number} liberada da memória principal."
            else:
                return f"Página {page_number} já está livre na memória principal."
        elif page_number < len(self.memory) + len(self.swap_memory):
            swap_page_number = page_number - len(self.memory)
            swap_page = self.swap_memory[swap_page_number]
            if swap_page["ocupada"]:
                swap_page["ocupada"] = False
                return f"Página {swap_page_number} liberada do swap."
            else:
                return f"Página {swap_page_number} já está livre no swap."
        else:
            return f"Número de página inválido: {page_number}"

    def get_memory_status(self):
        status_memory = "\n".join([f"Página {i}: {'Ocupada' if page['ocupada'] else 'Livre'}, {'Lotada' if page['lotada'] else 'Não Lotada' if not page['ocupada'] else 'Lotada'}" for i, page in enumerate(self.memory)])
        status_swap = "\n".join([f"Página {i}: {'Ocupada' if page['ocupada'] else 'Livre'}, {'Lotada' if page['lotada'] else 'Não Lotada' if not page['ocupada'] else 'Lotada'}" for i, page in enumerate(self.swap_memory)])
        return status_memory, status_swap


class MemoryManagerGUI:
    def __init__(self, master):
        self.master = master
        master.title("Gerenciador de Memória")
        master.geometry("600x400")
        self.memory_manager = MemoryManager()
        self.memory = self.memory_manager.memory
        self.swap_memory = self.memory_manager.swap_memory

        self.create_widgets()

    def create_widgets(self):
        self.initialize_memory_button = ttk.Button(self.master, text="Inicializar Memória", command=lambda: self.memory_manager.initialize_memory(self))
        self.initialize_memory_button.pack(padx=10, pady=5)

        self.allocate_memory_button = ttk.Button(self.master, text="Alocar Memória", command=self.allocate_memory_dialog)
        self.allocate_memory_button.pack(padx=10, pady=5)

        self.deallocate_memory_button = ttk.Button(self.master, text="Desalocar Memória",
                                                   command=self.deallocate_memory_dialog)
        self.deallocate_memory_button.pack(padx=10, pady=5)

        self.memory_status_button = ttk.Button(self.master, text="Status da Memória", command=self.show_memory_status)
        self.memory_status_button.pack(padx=10, pady=5)

        self.memory_graph_button = ttk.Button(self.master, text="Gráfico de Memória", command=self.show_memory_graph)
        self.memory_graph_button.pack(padx=10, pady=5)

        self.quit_button = ttk.Button(self.master, text="Sair", command=self.master.quit)
        self.quit_button.pack(padx=10, pady=5)

        self.text_output = tk.Text(self.master, height=10, width=50, wrap="word")
        self.text_output.pack(padx=10, pady=5)

        self.scrollbar = Scrollbar(self.master, command=self.text_output.yview)
        self.scrollbar.pack(side="right", fill="y")
        self.text_output.config(yscrollcommand=self.scrollbar.set)

    def allocate_memory_dialog(self):
        num_pages = simpledialog.askinteger("Alocar Memória", "Digite o número de páginas para alocar:")
        if num_pages is not None:
            result = self.memory_manager.allocate_memory(num_pages)
            self.text_output.insert(tk.END, f"{result}\n")
            self.show_memory_status()

    def deallocate_memory_dialog(self):
        page_number = simpledialog.askinteger("Desalocar Memória", "Digite o número da página para desalocar:")
        if page_number is not None:
            result = self.memory_manager.deallocate_memory(page_number)
            self.text_output.insert(tk.END, f"{result}\n")
            self.show_memory_status()

    def show_memory_status(self):
        status_memory, status_swap = self.memory_manager.get_memory_status()
        self.text_output.delete(1.0, tk.END)
        self.text_output.insert(tk.END, "Status da Memória Principal:\n")
        self.text_output.insert(tk.END, status_memory + "\n\n")
        self.text_output.insert(tk.END, "Status do Swap:\n")
        self.text_output.insert(tk.END, status_swap + "\n")

    def show_memory_graph(self):
        # Remover o gráfico anterior se já existir
        for widget in self.master.winfo_children():
            if isinstance(widget, FigureCanvasTkAgg):
                widget.get_tk_widget().destroy()

        # Criar o novo gráfico
        fig, ax = plt.subplots(figsize=(6, 4))
        ax.bar(['Ocupada', 'Livre'], [sum(page['ocupada'] for page in self.memory_manager.memory),
                                      len(self.memory_manager.memory) - sum(
                                          page['ocupada'] for page in self.memory_manager.memory)],
               color=['blue', 'gray'])
        ax.set_ylabel('Número de Páginas')
        ax.set_title('Estado da Memória Principal')

        # Atualizar o canvas com o novo gráfico
        canvas = FigureCanvasTkAgg(fig, master=self.master)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Atualizar a barra de rolagem se necessário
        self.master.update_idletasks()
        self.text_output.config(yscrollcommand=self.scrollbar.set)

        # Atualizar a interface após mostrar o gráfico
        self.master.update()
root = tk.Tk()
app = MemoryManagerGUI(root)
root.mainloop()
